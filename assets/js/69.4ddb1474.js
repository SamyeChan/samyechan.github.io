(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{371:function(t,n,e){"use strict";e.r(n);var i=e(0),l=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"移动端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#移动端","aria-hidden":"true"}},[t._v("#")]),t._v(" 移动端")]),t._v(" "),e("ol",[e("li",[t._v("函数防抖和函数节流的区别？")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("&&防抖：所谓防抖，就是指触发事件后在n秒内函数只能执行一次，如果在n秒内又触发了事件，则会重新计算函数执行时间。【比如人的眨眼睛，就是一定时间内眨一次】\n&&举个栗子：滚动scroll事件，不停滑动滚轮会连续触发多次滚动事件，从而调用绑定的回调函数，我们希望当我们停止滚动的时候，才触发一次回调，这时可以使用函数防抖。\n&&节流：所谓节流，就是指连续触发事件但是在n秒中只执行一次函数。节流会稀释函数的执行频率。【就是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车】\n&&举个栗子：还是以scroll滚动事件来说吧，滚动事件是及其消耗浏览器性能的，不停触发。比如移动端通过scroll实现分页，不断滚动，我们不希望不断发送请求，只有当达到某个条件，比如，距离手机窗口底部150px才发送一个请求，接下来就是战士新页面的请求，不停滚动，如此反复；这个时候就得用到函数节流了。")]),t._v(" "),e("p",[t._v("2.函数防抖的应用场景？\n给按钮加函数防抖防止表单多次提交；\n对于输入框连续输入进行AJAX验证时，用函数防抖能有效减少请求次数；函数防抖和函数节流的区别？\n判断scroll是否滑到底部，滚动事件+函数防抖；\nwindow的resize事件避免频繁被加载；")])])]),t._v(" "),e("p",[t._v("3.函数节流的应用场景？\n节流可以将一些事件降低触发频率。比如懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费资源；另外还有做商品预览图的放大镜效果时，不必每次鼠标移动都计算位置。")]),t._v(" "),e("p",[t._v("4.如何使用定时器实现防抖和节流？\n节流思路：每两秒允许触发一次计数时间，设置一个计数变量'timeout',每次执行加法的时候判断timeout是否为0；\n如果为0，则执行加法，将timeout变为2000，设置计数时间，在两秒后置零timeout;否则因为timeout没有置零，什么都不做，干等着就行了。\n防抖思路：冷却事件不够，就重新计算冷却时间，直至冷却时间够了再调用。")])])}],!1,null,null,null);n.default=l.exports}}]);